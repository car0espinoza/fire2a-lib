<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fire2a-lib.src.fire2a.downstream_protection_value API documentation</title>
<meta name="description" content="DownStream Protection Value Algorithm can be reduced to recursively counting out nodes in a directed tree graph; When providing node values, â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fire2a-lib.src.fire2a.downstream_protection_value</code></h1>
</header>
<section id="section-intro">
<p>DownStream Protection Value Algorithm can be reduced to recursively counting out nodes in a directed tree graph; When providing node values, recursively summing them. In the context of Cell2Fire simulator, the graph is a (or many) fire propagation tree(s), represented in a (multi) directed graph.</p>
<p>Its main idea is that upstream cells are priority over downstream cells because of the calculated fire propagations; So if you protect an upstream cell, fire won't get to the downstream cells; pondered by the protection values</p>
<p>Its inputs are:</p>
<ul>
<li>A directed graph(*), passed as a 'Messages.csv' file, with 'in_node', 'out_node', 'weight' columns</li>
<li>[optional] a raster with the values to protect (any Non-Data, any Value types) As the aggregation function is sum, means bigger values are more protection than smaller or negative values.</li>
</ul>
<p>Its output is:</p>
<ul>
<li>A raster represeting the graph with added values (or number of cells) downstream (or out nodes, recursively).</li>
</ul>
<p>(*): If it is not a tree, it will be reduced to a tree by the shortest path algorithm</p>
<p>This code:</p>
<ul>
<li>Reads all Messages[0-9]+.csv files from a directory ([0-9]+ represents any integer number)</li>
<li>Reads the protection values from a gdal compatible raster file</li>
<li>Calculates the downstream protection value algorithm serially for windows, and parallel for linux</li>
<li>Is hooked up to usage_template/downstream_protection_value.ipynb for graphical exploration</li>
</ul>
<p><a href="https://fire2a.github.io/fire2a-lib/src/fire2a/downstream_protection_value.html">https://fire2a.github.io/fire2a-lib/src/fire2a/downstream_protection_value.html</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/bin/env python3
__author__ = &#34;Fernando Badilla&#34;
__revision__ = &#34;$Format:%H$&#34;
__doc__ = &#34;&#34;&#34;
DownStream Protection Value Algorithm can be reduced to recursively counting out nodes in a directed tree graph; When providing node values, recursively summing them. In the context of Cell2Fire simulator, the graph is a (or many) fire propagation tree(s), represented in a (multi) directed graph.

Its main idea is that upstream cells are priority over downstream cells because of the calculated fire propagations; So if you protect an upstream cell, fire won&#39;t get to the downstream cells; pondered by the protection values

Its inputs are:

* A directed graph(*), passed as a &#39;Messages.csv&#39; file, with &#39;in_node&#39;, &#39;out_node&#39;, &#39;weight&#39; columns
* [optional] a raster with the values to protect (any Non-Data, any Value types) As the aggregation function is sum, means bigger values are more protection than smaller or negative values.

Its output is:

* A raster represeting the graph with added values (or number of cells) downstream (or out nodes, recursively).

(*): If it is not a tree, it will be reduced to a tree by the shortest path algorithm

This code:

* Reads all Messages[0-9]+.csv files from a directory ([0-9]+ represents any integer number)
* Reads the protection values from a gdal compatible raster file
* Calculates the downstream protection value algorithm serially for windows, and parallel for linux
* Is hooked up to usage_template/downstream_protection_value.ipynb for graphical exploration

https://fire2a.github.io/fire2a-lib/src/fire2a/downstream_protection_value.html
&#34;&#34;&#34;
import logging
import re
import sys
from pathlib import Path

import networkx as nx
import numpy as np
from matplotlib import pyplot as plt
from networkx import DiGraph
from numpy import ndarray
from osgeo import gdal

from fire2a import setup_logger
from fire2a.raster import id2xy as r_id2xy
from fire2a.raster import read_raster

logger = logging.getLogger(__name__)


def id2xy(idx, w=40, h=40):
    &#34;&#34;&#34;idx: index, w: width, h:height&#34;&#34;&#34;
    return r_id2xy(idx - 1, w, h)


# def id2xy(idx, w=40, h=40):
#     &#34;&#34;&#34;idx: index, w: width, h:height&#34;&#34;&#34;
#     idx -= 1
#     return idx % w, idx // w

# def read_raster(filename: str, band: int = 1, data: bool = True, info: bool = True) -&gt; tuple[np.ndarray, dict]:


def single_simulation_downstream_protection_value(msgfile=&#34;MessagesFile01.csv&#34;, pvfile=&#34;py.asc&#34;):
    &#34;&#34;&#34;load one diGraph count succesors&#34;&#34;&#34;
    msgG, root = digraph_from_messages(msgfile)
    treeG = shortest_propagation_tree(msgG, root)
    pv, W, H = get_flat_pv(pvfile)
    #
    dpv = np.zeros(pv.shape, dtype=pv.dtype)
    i2n = [n - 1 for n in treeG]
    mdpv = dpv_maskG(treeG, root, pv, i2n)
    dpv[i2n] = mdpv
    return mdpv, dpv


def downstream_protection_value(out_dir, pvfile):
    pv, W, H = get_flat_pv(pvfile)
    dpv = np.zeros(pv.shape, dtype=pv.dtype)
    file_list = read_files(out_dir)
    for msgfile in file_list:
        msgG, root = digraph_from_messages(msgfile)
        treeG = shortest_propagation_tree(msgG, root)
        i2n = [n - 1 for n in treeG]  # TODO change to list(treeG)
        mdpv = dpv_maskG(treeG, root, pv, i2n)
        dpv[i2n] += mdpv
        # plot_pv( dpv, w=W, h=H)
    return dpv / len(file_list)


def canon3(afile):
    # NO IMPLEMENTADO
    G = nx.read_edgelist(
        path=afile, create_using=nx.DiGraph(), nodetype=np.int32, data=[(&#34;time&#34;, np.int16)], delimiter=&#34;,&#34;
    )
    return G


def canon4(afile):
    G = nx.read_edgelist(
        path=afile,
        create_using=nx.DiGraph(),
        nodetype=np.int32,
        data=[(&#34;time&#34;, np.int16), (&#34;ros&#34;, np.float32)],
        delimiter=&#34;,&#34;,
    )
    return G


def digraph_from_messages(afile):
    &#34;&#34;&#34;Not checking if file exists or if size &gt; 0
    This is done previously on read_files
    &#34;&#34;&#34;
    data = np.loadtxt(
        afile, delimiter=&#34;,&#34;, dtype=[(&#34;i&#34;, np.int32), (&#34;j&#34;, np.int32), (&#34;time&#34;, np.int16)], usecols=(0, 1, 2)
    )
    root = data[0][0]  # checkar que el primer valor del message sea el punto de igniciÃ³n
    G = nx.DiGraph()
    G.add_weighted_edges_from(data)
    return G, root


func = np.vectorize(lambda x, y: {&#34;time&#34;: x, &#34;ros&#34;: y})


def custom4(afile):
    data = np.loadtxt(
        afile, delimiter=&#34;,&#34;, dtype=[(&#34;i&#34;, np.int32), (&#34;j&#34;, np.int32), (&#34;time&#34;, np.int16), (&#34;ros&#34;, np.float32)]
    )
    root = data[0][0]
    G = nx.DiGraph()
    bunch = np.vstack((data[&#34;i&#34;], data[&#34;j&#34;], func(data[&#34;time&#34;], data[&#34;ros&#34;]))).T
    G.add_edges_from(bunch)
    return G.add_edges_from(bunch), root


def shortest_propagation_tree(G, root):
    &#34;&#34;&#34;construct a tree with the all shortest path from root
    TODO try accumulating already added edges for checking before asigning should be faster?
    &#34;&#34;&#34;
    # { node : [root,...,node], ... }
    shortest_paths = nx.single_source_dijkstra_path(G, root, weight=&#34;time&#34;)
    del shortest_paths[root]
    T = nx.DiGraph()
    for node, shopat in shortest_paths.items():
        for i, node in enumerate(shopat[:-1]):
            T.add_edge(node, shopat[i + 1])
    return T


def recursiveUp(G):
    &#34;&#34;&#34;count up WTF!!!
    leafs = [x for x in T.nodes if T.out_degree(x)==0]
    &#34;&#34;&#34;
    for i in G.nodes:
        G.nodes[i][&#34;dv&#34;] = 1

        # G.nodes[i][&#39;dv&#39;]=0
    # for leaf in (x for x in G.nodes if G.out_degree(x)==0):
    #    G.nodes[leaf][&#39;dv&#39;]=1
    def count_up(G, j):
        for i in G.predecessors(j):
            # G.nodes[i][&#39;dv&#39;]+=G.nodes[j][&#39;dv&#39;]
            G.nodes[i][&#34;dv&#34;] += 1
            print(i, j, G.nodes[i][&#34;dv&#34;])
            count_up(G, i)

    for leaf in (x for x in G.nodes if G.out_degree(x) == 0):
        count_up(G, leaf)


def dpv_maskG(G, root, pv, i2n=None):
    &#34;&#34;&#34;calculate downstream protection value in a flat protection value raster
    i2n = [n for n in treeG.nodes]
    1. copies a slice of pv, only Graph nodes
    2. recursively sums downstream for all succesors of the graph (starting from root)
    3. returns the slice (range(len(G) indexed)
    G must be a tree
    &#34;&#34;&#34;
    if i2n is None:
        i2n = [n - 1 for n in treeG]
    # -1 ok?
    mdpv = pv[i2n]

    # assert mdpv.base is None ,&#39;the slice is not a copy!&#39;
    def recursion(G, i, pv, mdpv, i2n):
        for j in G.successors(i):
            mdpv[i2n.index(i - 1)] += recursion(G, j, pv, mdpv, i2n)
        return mdpv[i2n.index(i - 1)]

    recursion(G, root, pv, mdpv, i2n)
    return mdpv


def recursion2(G: DiGraph, i: np.int32, mdpv: ndarray, i2n: list[int]) -&gt; ndarray:
    for j in G.successors(i):
        mdpv[i2n.index(i)] += recursion2(G, j, mdpv, i2n)
    return mdpv[i2n.index(i)]


def add_dpv_graph(G, root, pv):
    &#34;&#34;&#34;modifies the input Graph recursively:
        1. sums pv into predecesor (or calling)
        2. recursively sums downstream for all succesors
        3. returns itself if no successors
    G must be a tree with &#39;dv&#39;
    hence returns nothing
    &#34;&#34;&#34;
    for n in G.nodes:
        G.nodes[n][&#34;dv&#34;] += pv[n - 1]

    def recursion(G, i):
        for j in G.successors(i):
            G.nodes[i][&#34;dv&#34;] += recursion(G, j)
        return G.nodes[i][&#34;dv&#34;]

    recursion(G, root)


def sum_dpv_graph(T, root, pv):
    &#34;&#34;&#34;returns a copy of T that:
        1. sets pv into each node
        2. recursively sums pv downstream
    T must be a tree (not checked)
    &#34;&#34;&#34;
    G = T.copy()
    for i in G.nodes:
        G.nodes[i][&#34;dv&#34;] = pv[i - 1]

    def recursion(G, i):
        for j in G.successors(i):
            G.nodes[i][&#34;dv&#34;] += recursion(G, j)
        return G.nodes[i][&#34;dv&#34;]

    recursion(G, root)
    return G


def count_downstream_graph(T, root) -&gt; nx.DiGraph:
    &#34;&#34;&#34;returns a new Graph with node values of the number of conected nodes downstream&#34;&#34;&#34;
    assert nx.is_tree(T), &#34;not tree&#34;
    G = T.copy()
    for i in G.nodes:
        G.nodes[i][&#34;dv&#34;] = 1

    def recursion(G, i):
        for j in G.successors(i):
            G.nodes[i][&#34;dv&#34;] += recursion(G, j)
        return G.nodes[i][&#34;dv&#34;]

    recursion(G, root)
    return G


def glob_int_sorted(directory: Path, filename: str = &#34;MessagesFile.csv&#34;):
    &#34;&#34;&#34;reads all MessagesFile&lt;int&gt;.csv &gt;0 size files from directory, regexes numbers casting to int, sorts them
    Args:
        directory (Path): directory to read
        filename (str): filename to match
    Returns:
        list: ordered list of pathlib files
    &#34;&#34;&#34;
    if not directory.is_dir():
        raise NotADirectoryError(f&#34;{directory=} is not a directory&#34;)
    file_name = Path(filename)
    file_list = [f for f in directory.glob(file_name.stem + &#34;[0-9]*&#34; + file_name.suffix) if f.stat().st_size &gt; 0]
    if len(file_list) == 0:
        raise FileNotFoundError(f&#34;{directory=} has no {file_name=} matching &gt;0 size files&#34;)
    file_string = &#34; &#34;.join([f.stem for f in file_list])
    # sort
    sim_num = np.fromiter(re.findall(&#34;([0-9]+)&#34;, file_string), dtype=int, count=len(file_list))
    asort = np.argsort(sim_num)
    sim_num = sim_num[asort]
    file_list = list(np.array(file_list)[asort])
    return file_list


def get_flat_pv(afile):
    &#34;&#34;&#34;opens the file with gdal as raster, get 1st band, flattens it
    also returns width and height
    &#34;&#34;&#34;
    dataset = gdal.Open(str(afile), gdal.GA_ReadOnly)
    return dataset.GetRasterBand(1).ReadAsArray().ravel(), dataset.RasterXSize, dataset.RasterYSize


def plot(G, pos=None, labels=None):
    &#34;&#34;&#34;matplotlib
    TODO scientific format numeric labels
    &#34;&#34;&#34;
    if not pos:
        pos = {node: [*id2xy(node)] for node in G.nodes}
    if not labels:
        labes = {node: node for node in G.nodes}
    plt.figure()
    nx.draw(G, pos=pos, with_labels=False)
    nx.draw_networkx_labels(G, pos=pos, labels=labels)
    return plt.show()


def plot_pv(pv, w=40, h=40):
    mat = pv.reshape(h, w)
    plt.matshow(mat)
    plt.show()


def worker(data, pv, sid):

    # digraph_from_messages(msgfile) -&gt; msgG, root
    msgG = DiGraph()
    msgG.add_weighted_edges_from(data)
    root = data[0][0]
    # shortest_propagation_tree(G, root) -&gt; treeG
    shortest_paths = nx.single_source_dijkstra_path(msgG, root, weight=&#34;time&#34;)
    del shortest_paths[root]
    treeG = DiGraph()
    for node, shopat in shortest_paths.items():
        for i, node in enumerate(shopat[:-1]):
            treeG.add_edge(node, shopat[i + 1])
    # dpv_maskG(G, root, pv, i2n) -&gt; mdpv
    i2n = [n for n in treeG]
    mdpv = pv[i2n]
    recursion(treeG, root, mdpv, i2n)
    # dpv[i2n] += mdpv
    return mdpv, i2n, sid


from re import search


def load_msg(afile: Path):
    try:
        sim_id = search(&#34;\\d+&#34;, afile.stem).group(0)
    except:
        sim_id = &#34;-1&#34;
    data = loadtxt(
        afile, delimiter=&#34;,&#34;, dtype=[(&#34;i&#34;, np.int32), (&#34;j&#34;, np.int32), (&#34;t&#34;, np.int32)], usecols=(0, 1, 2), ndmin=1
    )
    return data, sim_id


def get_data(files, callback=None):
    data = []
    for count, afile in enumerate(files):
        sim_id = search(&#34;\\d+&#34;, afile.stem).group(0)
        data += [
            loadtxt(
                afile,
                delimiter=&#34;,&#34;,
                dtype=[(&#34;i&#34;, np.int32), (&#34;j&#34;, np.int32), (&#34;t&#34;, np.int32)],
                usecols=(0, 1, 2),
                ndmin=1,
            )
        ]
        # 1 based to 0 based
        data[-1][&#34;i&#34;] -= 1
        data[-1][&#34;j&#34;] -= 1
        if callback:
            callback(count, sim_id, afile)
        yield data
    with open(&#34;messages.pickle&#34;, &#34;wb&#34;) as f:
        pickle_dump(data, f)


def one_sim_work(afile, pv, sid):
    # digraph_from_messages(msgfile) -&gt; msgG, root
    data = np.loadtxt(
        afile,
        delimiter=&#34;,&#34;,
        dtype=[(&#34;i&#34;, np.int32), (&#34;j&#34;, np.int32), (&#34;t&#34;, np.int32)],
        usecols=(0, 1, 2),
        ndmin=1,
    )
    # 1 based to 0 based
    data[&#34;i&#34;] -= 1
    data[&#34;j&#34;] -= 1
    msgG = nx.DiGraph()
    msgG.add_weighted_edges_from(data)
    root = data[0][0]
    # shortest_propagation_tree(G, root) -&gt; treeG
    shortest_paths = nx.single_source_dijkstra_path(msgG, root, weight=&#34;time&#34;)
    del shortest_paths[root]
    treeG = nx.DiGraph()
    for node, shopat in shortest_paths.items():
        for i, node in enumerate(shopat[:-1]):
            treeG.add_edge(node, shopat[i + 1])
    # dpv_maskG(G, root, pv, i2n) -&gt; mdpv
    i2n = [n for n in treeG]
    mdpv = pv[i2n]
    recursion2(treeG, root, mdpv, i2n)
    # dpv[i2n] += mdpv
    print(&#34;fin&#34;, sid)
    return mdpv, i2n, sid


def argument_parser(argv):
    &#34;&#34;&#34;parse arguments
    - logger: verbosity, logfile
    &#34;&#34;&#34;
    import argparse

    def path_check(path):
        path = Path(path)
        if path.is_dir() or (path.is_file() and path.stat().st_size &gt; 0):
            return path
        raise argparse.ArgumentTypeError(f&#34;{path.as_uri()=} is not a valid Path or file size is 0&#34;)

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        &#34;-v&#34;,
        &#34;--verbosity&#34;,
        help=&#34;increase output verbosity (0: warning(default), 1: info, 2&gt;=: debug)&#34;,
        action=&#34;count&#34;,
        default=0,
    )
    parser.add_argument(&#34;-l&#34;, &#34;--logfile&#34;, help=&#34;rotating log file see fire2a.setup_logger&#34;, type=Path)
    parser.add_argument(
        &#34;-dpvn&#34;,
        &#34;--dpv-filename&#34;,
        help=&#34;dpv raster layer output filename&#34;,
        type=str,
        default=&#34;dpv.tif&#34;,
    )
    parser.add_argument(
        &#34;-pv&#34;,
        &#34;--protection-value&#34;,
        help=&#34;pv raster layer, must be gdal.Open compatible, and match messages width &amp; height&#34;,
        type=path_check,
    )
    parser.add_argument(
        &#34;-pvb&#34;,
        &#34;--protection-value-band&#34;,
        help=&#34;pv raster layer band to read, defaults to 1&#34;,
        type=int,
        default=1,
    )
    parser.add_argument(&#34;-W&#34;, help=&#34;width of the raster (overrides width read from pv raster)&#34;, type=int)
    parser.add_argument(&#34;-H&#34;, help=&#34;height of the raster (overrides width read from pv raster)&#34;, type=int)
    parser.add_argument(
        nargs=&#34;+&#34;,
        dest=&#34;messages&#34;,
        help=(
            &#34;Messages[0-9+].csv file(s) or directory to parse (hint use glob: Messages*.csv to pass many files or pass&#34;
            &#34; a single directory to read all Messages[0-9+].csv files in it)&#34;
        ),
        type=path_check,
    )
    return parser.parse_args(argv)


def main(argv=None):
    &#34;&#34;&#34;steps to run dpv&#34;&#34;&#34;
    if argv is None:
        argv = sys.argv[1:]
    args = argument_parser(argv)
    logger = setup_logger(__name__, args.verbosity, args.logfile)
    logger.info(f&#34;{args=}&#34;)
    logger.debug(&#34;debugging...&#34;)

    file_list = []
    for path_str in args.messages:
        path = Path(path_str)
        if path.is_file() and path.stat().st_size &gt; 0:
            file_list += [path]
        elif path.is_dir():
            file_list += glob_int_sorted(path)
        else:
            logger.warning(f&#34;{path} is not a file or directory&#34;)
    # remove duplicates
    file_list = list(dict.fromkeys(file_list))
    logger.info(f&#34;{file_list=}&#34;)

    if args.protection_value:
        pv_data, pv_info = read_raster(str(args.protection_value), args.protection_value_band)
        W, H, GT, PJ = pv_info[&#34;RasterXSize&#34;], pv_info[&#34;RasterYSize&#34;], pv_info[&#34;Transform&#34;], pv_info[&#34;Projection&#34;]
        # make 1D
        pv = pv_data.ravel()
        logger.info(f&#34;{pv_data.dtype=}, {pv_data.shape=}, {pv_info=}&#34;)
        dpv = np.zeros(pv.shape, dtype=pv.dtype)
    elif args.W and args.H:
        W, H = args.W, args.H
        GT = (0, 1, 0, 0, 0, 1)
        PJ = &#34;EPSG:4326&#34;
        pv = np.ones(W * H, dtype=np.int32)
        dpv = np.zeros(W * H, dtype=np.int32)

    from multiprocessing import Pool, cpu_count

    with Pool(processes=cpu_count() - 1) as pool:
        results = [pool.apply_async(one_sim_work, args=(afile, pv, i)) for i, afile in enumerate(file_list)]
        for result in results:
            sdpv, si2n, sid = result.get()
            dpv[si2n] += sdpv
    # scale
    dpv = dpv / len(file_list)
    print(f&#34;{dpv=}&#34;)
    # write
    dst_ds = gdal.GetDriverByName(&#34;GTiff&#34;).Create(args.dpv_filename, W, H, 1, gdal.GDT_Float32)
    # get driver by name to create a geo tiff raster
    dst_ds.SetGeoTransform(GT)
    dst_ds.SetProjection(PJ)
    band = dst_ds.GetRasterBand(1)
    band.SetUnitType(&#34;protection_value&#34;)
    if 0 != band.SetNoDataValue(0):
        feedback.pushWarning(f&#34;Set No Data failed for {self.OUT_R}&#34;)
    if 0 != band.WriteArray(np.float32(dpv.reshape(H, W))):
        feedback.pushWarning(f&#34;WriteArray failed for {self.OUT_R}&#34;)
    band.FlushCache()
    dst_ds.FlushCache()
    dst_ds = None
    return 0


if __name__ == &#34;__main__&#34;:
    sys.exit(main())


def no():
    # if len(sys.argv)&gt;1:
    #     input_dir = sys.argv[1]
    #     output_dir = sys.argv[2]
    # else:
    print(&#34;run in C2FSB folder&#34;)
    # input_dir = Path.cwd() / &#39;data&#39;
    input_dir = Path(&#34;/home/fdo/source/C2F-W3/data/Vilopriu_2013/firesim_231008_110004&#34;)
    # output_dir = Path.cwd() / &#39;results&#39;
    output_dir = Path(&#34;/home/fdo/source/C2F-W3/data/Vilopriu_2013/firesim_231008_110004/results&#34;)
    print(input_dir, output_dir)
    assert input_dir.is_dir() and output_dir.is_dir()

    # abro el directorio de los messages como una lista con los nombres de los archivos
    file_list = read_files(output_dir)

    # agarrar la capa que ocuparemos como valor a proteger
    ## pv: valores en riesgo
    ## W: Width
    ## H: Height
    pv, W, H = get_flat_pv(input_dir / &#34;fuels.asc&#34;)

    #
    # single simulation
    #
    afile = file_list[0]
    msgG, root = digraph_from_messages(afile)
    pos = {node: [*id2xy(node)] for node in msgG}
    treeG = shortest_propagation_tree(msgG, root)

    # count the number of nodes downstream
    countG = count_downstream_graph(treeG, root)

    # asignar el nÃºmero de nodos aguas abajo a cada nodo respectivamente
    countGv = {n: countG.nodes[n][&#34;dv&#34;] for n in countG}
    plot(countG, pos=pos, labels=countGv)
    # {&#39;dv&#39;: 137} == 137 root connects all tree
    assert countG.nodes[root][&#34;dv&#34;] == len(countG), &#34;count_downstream at root is not the same as number of nodes!&#34;
    #
    onev = np.ones(pv.shape)
    #
    # sum dpv=1
    sumG = sum_dpv_graph(treeG, root, onev)
    sumGv = {n: sumG.nodes[n][&#34;dv&#34;] for n in sumG}
    plot(sumG, pos=pos, labels=sumGv)
    assert np.all([sumGv[n] == countGv[n] for n in treeG.nodes]), &#34;sum_dpv(pv=1) != countG values!&#34;
    #
    # add dpv=1
    addG = treeG.copy()
    for n in addG.nodes:
        addG.nodes[n][&#34;dv&#34;] = 0
    add_dpv_graph(addG, root, onev)
    addGv = {n: addG.nodes[n][&#34;dv&#34;] for n in addG}
    plot(addG, pos=pos, labels=addGv)
    assert np.all([addGv[n] == countGv[n] for n in treeG.nodes]), &#34;add_dpv(pv=1) != countG values!&#34;
    #
    # cum dpv=1
    dpv = np.zeros(pv.shape, dtype=pv.dtype)
    i2n = [n - 1 for n in treeG]
    mdpv = dpv_maskG(treeG, root, onev, i2n)
    dpv[i2n] = mdpv
    plot_pv(dpv, w=W, h=H)
    assert np.all([mdpv[i2n.index(n - 1)] == countGv[n] for n in treeG.nodes]), &#34;dpv_maskG(pv=1) != countG values!&#34;
    #
    # single full test
    mdpv, dpv = single_simulation_downstream_protection_value(msgfile=afile, pvfile=input_dir / &#34;bp.asc&#34;)
    plot_pv(dpv, w=W, h=H)
    plot(treeG, pos=pos, labels={n: np.format_float_scientific(dpv[n], precision=2) for n in treeG})
    assert np.all(np.isclose(mdpv, dpv[i2n])), &#34;dpv_maskG != dpvalues!&#34;
    #
    # finally
    dpv = downstream_protection_value(output_dir, pvfile=input_dir / &#34;bp.asc&#34;)
    plot_pv(dpv, w=W, h=H)


&#34;&#34;&#34;
$cd C2FSB
C2FSB$ python3 downstream_protection_value.py

all functions are tested and plotted on main

Calculate downstream protection value from Messages/MessagesFile&lt;int&gt;.csv files
Each file has 4 columns: from cellId, to cellId, period when burns &amp; hit ROS

https://github.com/fire2a/C2FK/blob/main/Cell2Fire/Heuristics.py

https://networkx.org/documentation/networkx-1.8/reference/algorithms.shortest_paths.html

propagation tree: (c) fire shortest traveling times

Performance review
1. is faster to dijkstra than minimun spanning

    In [50]: %timeit shortest_propagation_tree(G,root)
    1.53 ms Â± 5.47 Âµs per loop (mean Â± std. dev. of 7 runs, 1000 loops each)
    
    In [51]: %timeit nx.minimum_spanning_arborescence(G, attr=&#39;time&#39;)
    16.4 ms Â± 61 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)

2. is faster numpy+add_edges than nx.from_csv

    In [63]: %timeit custom4(afile)
    2.3 ms Â± 32 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
    
    In [64]: %timeit canon4(afile)
    3.35 ms Â± 20 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)

2.1 even faster is you discard a column!!
    In [65]: %timeit digraph_from_messages(afile)
    1.84 ms Â± 15.4 Âµs per loop (mean Â± std. dev. of 7 runs, 1000 loops each)

&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.add_dpv_graph"><code class="name flex">
<span>def <span class="ident">add_dpv_graph</span></span>(<span>G, root, pv)</span>
</code></dt>
<dd>
<div class="desc"><p>modifies the input Graph recursively:
1. sums pv into predecesor (or calling)
2. recursively sums downstream for all succesors
3. returns itself if no successors
G must be a tree with 'dv'
hence returns nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_dpv_graph(G, root, pv):
    &#34;&#34;&#34;modifies the input Graph recursively:
        1. sums pv into predecesor (or calling)
        2. recursively sums downstream for all succesors
        3. returns itself if no successors
    G must be a tree with &#39;dv&#39;
    hence returns nothing
    &#34;&#34;&#34;
    for n in G.nodes:
        G.nodes[n][&#34;dv&#34;] += pv[n - 1]

    def recursion(G, i):
        for j in G.successors(i):
            G.nodes[i][&#34;dv&#34;] += recursion(G, j)
        return G.nodes[i][&#34;dv&#34;]

    recursion(G, root)</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.argument_parser"><code class="name flex">
<span>def <span class="ident">argument_parser</span></span>(<span>argv)</span>
</code></dt>
<dd>
<div class="desc"><p>parse arguments
- logger: verbosity, logfile</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def argument_parser(argv):
    &#34;&#34;&#34;parse arguments
    - logger: verbosity, logfile
    &#34;&#34;&#34;
    import argparse

    def path_check(path):
        path = Path(path)
        if path.is_dir() or (path.is_file() and path.stat().st_size &gt; 0):
            return path
        raise argparse.ArgumentTypeError(f&#34;{path.as_uri()=} is not a valid Path or file size is 0&#34;)

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        &#34;-v&#34;,
        &#34;--verbosity&#34;,
        help=&#34;increase output verbosity (0: warning(default), 1: info, 2&gt;=: debug)&#34;,
        action=&#34;count&#34;,
        default=0,
    )
    parser.add_argument(&#34;-l&#34;, &#34;--logfile&#34;, help=&#34;rotating log file see fire2a.setup_logger&#34;, type=Path)
    parser.add_argument(
        &#34;-dpvn&#34;,
        &#34;--dpv-filename&#34;,
        help=&#34;dpv raster layer output filename&#34;,
        type=str,
        default=&#34;dpv.tif&#34;,
    )
    parser.add_argument(
        &#34;-pv&#34;,
        &#34;--protection-value&#34;,
        help=&#34;pv raster layer, must be gdal.Open compatible, and match messages width &amp; height&#34;,
        type=path_check,
    )
    parser.add_argument(
        &#34;-pvb&#34;,
        &#34;--protection-value-band&#34;,
        help=&#34;pv raster layer band to read, defaults to 1&#34;,
        type=int,
        default=1,
    )
    parser.add_argument(&#34;-W&#34;, help=&#34;width of the raster (overrides width read from pv raster)&#34;, type=int)
    parser.add_argument(&#34;-H&#34;, help=&#34;height of the raster (overrides width read from pv raster)&#34;, type=int)
    parser.add_argument(
        nargs=&#34;+&#34;,
        dest=&#34;messages&#34;,
        help=(
            &#34;Messages[0-9+].csv file(s) or directory to parse (hint use glob: Messages*.csv to pass many files or pass&#34;
            &#34; a single directory to read all Messages[0-9+].csv files in it)&#34;
        ),
        type=path_check,
    )
    return parser.parse_args(argv)</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.canon3"><code class="name flex">
<span>def <span class="ident">canon3</span></span>(<span>afile)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canon3(afile):
    # NO IMPLEMENTADO
    G = nx.read_edgelist(
        path=afile, create_using=nx.DiGraph(), nodetype=np.int32, data=[(&#34;time&#34;, np.int16)], delimiter=&#34;,&#34;
    )
    return G</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.canon4"><code class="name flex">
<span>def <span class="ident">canon4</span></span>(<span>afile)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canon4(afile):
    G = nx.read_edgelist(
        path=afile,
        create_using=nx.DiGraph(),
        nodetype=np.int32,
        data=[(&#34;time&#34;, np.int16), (&#34;ros&#34;, np.float32)],
        delimiter=&#34;,&#34;,
    )
    return G</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.count_downstream_graph"><code class="name flex">
<span>def <span class="ident">count_downstream_graph</span></span>(<span>T, root) â€‘>Â networkx.classes.digraph.DiGraph</span>
</code></dt>
<dd>
<div class="desc"><p>returns a new Graph with node values of the number of conected nodes downstream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_downstream_graph(T, root) -&gt; nx.DiGraph:
    &#34;&#34;&#34;returns a new Graph with node values of the number of conected nodes downstream&#34;&#34;&#34;
    assert nx.is_tree(T), &#34;not tree&#34;
    G = T.copy()
    for i in G.nodes:
        G.nodes[i][&#34;dv&#34;] = 1

    def recursion(G, i):
        for j in G.successors(i):
            G.nodes[i][&#34;dv&#34;] += recursion(G, j)
        return G.nodes[i][&#34;dv&#34;]

    recursion(G, root)
    return G</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.custom4"><code class="name flex">
<span>def <span class="ident">custom4</span></span>(<span>afile)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom4(afile):
    data = np.loadtxt(
        afile, delimiter=&#34;,&#34;, dtype=[(&#34;i&#34;, np.int32), (&#34;j&#34;, np.int32), (&#34;time&#34;, np.int16), (&#34;ros&#34;, np.float32)]
    )
    root = data[0][0]
    G = nx.DiGraph()
    bunch = np.vstack((data[&#34;i&#34;], data[&#34;j&#34;], func(data[&#34;time&#34;], data[&#34;ros&#34;]))).T
    G.add_edges_from(bunch)
    return G.add_edges_from(bunch), root</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.digraph_from_messages"><code class="name flex">
<span>def <span class="ident">digraph_from_messages</span></span>(<span>afile)</span>
</code></dt>
<dd>
<div class="desc"><p>Not checking if file exists or if size &gt; 0
This is done previously on read_files</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def digraph_from_messages(afile):
    &#34;&#34;&#34;Not checking if file exists or if size &gt; 0
    This is done previously on read_files
    &#34;&#34;&#34;
    data = np.loadtxt(
        afile, delimiter=&#34;,&#34;, dtype=[(&#34;i&#34;, np.int32), (&#34;j&#34;, np.int32), (&#34;time&#34;, np.int16)], usecols=(0, 1, 2)
    )
    root = data[0][0]  # checkar que el primer valor del message sea el punto de igniciÃ³n
    G = nx.DiGraph()
    G.add_weighted_edges_from(data)
    return G, root</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.downstream_protection_value"><code class="name flex">
<span>def <span class="ident">downstream_protection_value</span></span>(<span>out_dir, pvfile)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def downstream_protection_value(out_dir, pvfile):
    pv, W, H = get_flat_pv(pvfile)
    dpv = np.zeros(pv.shape, dtype=pv.dtype)
    file_list = read_files(out_dir)
    for msgfile in file_list:
        msgG, root = digraph_from_messages(msgfile)
        treeG = shortest_propagation_tree(msgG, root)
        i2n = [n - 1 for n in treeG]  # TODO change to list(treeG)
        mdpv = dpv_maskG(treeG, root, pv, i2n)
        dpv[i2n] += mdpv
        # plot_pv( dpv, w=W, h=H)
    return dpv / len(file_list)</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.dpv_maskG"><code class="name flex">
<span>def <span class="ident">dpv_maskG</span></span>(<span>G, root, pv, i2n=None)</span>
</code></dt>
<dd>
<div class="desc"><p>calculate downstream protection value in a flat protection value raster
i2n = [n for n in treeG.nodes]
1. copies a slice of pv, only Graph nodes
2. recursively sums downstream for all succesors of the graph (starting from root)
3. returns the slice (range(len(G) indexed)
G must be a tree</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dpv_maskG(G, root, pv, i2n=None):
    &#34;&#34;&#34;calculate downstream protection value in a flat protection value raster
    i2n = [n for n in treeG.nodes]
    1. copies a slice of pv, only Graph nodes
    2. recursively sums downstream for all succesors of the graph (starting from root)
    3. returns the slice (range(len(G) indexed)
    G must be a tree
    &#34;&#34;&#34;
    if i2n is None:
        i2n = [n - 1 for n in treeG]
    # -1 ok?
    mdpv = pv[i2n]

    # assert mdpv.base is None ,&#39;the slice is not a copy!&#39;
    def recursion(G, i, pv, mdpv, i2n):
        for j in G.successors(i):
            mdpv[i2n.index(i - 1)] += recursion(G, j, pv, mdpv, i2n)
        return mdpv[i2n.index(i - 1)]

    recursion(G, root, pv, mdpv, i2n)
    return mdpv</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>files, callback=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(files, callback=None):
    data = []
    for count, afile in enumerate(files):
        sim_id = search(&#34;\\d+&#34;, afile.stem).group(0)
        data += [
            loadtxt(
                afile,
                delimiter=&#34;,&#34;,
                dtype=[(&#34;i&#34;, np.int32), (&#34;j&#34;, np.int32), (&#34;t&#34;, np.int32)],
                usecols=(0, 1, 2),
                ndmin=1,
            )
        ]
        # 1 based to 0 based
        data[-1][&#34;i&#34;] -= 1
        data[-1][&#34;j&#34;] -= 1
        if callback:
            callback(count, sim_id, afile)
        yield data
    with open(&#34;messages.pickle&#34;, &#34;wb&#34;) as f:
        pickle_dump(data, f)</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.get_flat_pv"><code class="name flex">
<span>def <span class="ident">get_flat_pv</span></span>(<span>afile)</span>
</code></dt>
<dd>
<div class="desc"><p>opens the file with gdal as raster, get 1st band, flattens it
also returns width and height</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_flat_pv(afile):
    &#34;&#34;&#34;opens the file with gdal as raster, get 1st band, flattens it
    also returns width and height
    &#34;&#34;&#34;
    dataset = gdal.Open(str(afile), gdal.GA_ReadOnly)
    return dataset.GetRasterBand(1).ReadAsArray().ravel(), dataset.RasterXSize, dataset.RasterYSize</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.glob_int_sorted"><code class="name flex">
<span>def <span class="ident">glob_int_sorted</span></span>(<span>directory:Â pathlib.Path, filename:Â strÂ =Â 'MessagesFile.csv')</span>
</code></dt>
<dd>
<div class="desc"><p>reads all MessagesFile<int>.csv &gt;0 size files from directory, regexes numbers casting to int, sorts them</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>Path</code></dt>
<dd>directory to read</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename to match</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>ordered list of pathlib files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def glob_int_sorted(directory: Path, filename: str = &#34;MessagesFile.csv&#34;):
    &#34;&#34;&#34;reads all MessagesFile&lt;int&gt;.csv &gt;0 size files from directory, regexes numbers casting to int, sorts them
    Args:
        directory (Path): directory to read
        filename (str): filename to match
    Returns:
        list: ordered list of pathlib files
    &#34;&#34;&#34;
    if not directory.is_dir():
        raise NotADirectoryError(f&#34;{directory=} is not a directory&#34;)
    file_name = Path(filename)
    file_list = [f for f in directory.glob(file_name.stem + &#34;[0-9]*&#34; + file_name.suffix) if f.stat().st_size &gt; 0]
    if len(file_list) == 0:
        raise FileNotFoundError(f&#34;{directory=} has no {file_name=} matching &gt;0 size files&#34;)
    file_string = &#34; &#34;.join([f.stem for f in file_list])
    # sort
    sim_num = np.fromiter(re.findall(&#34;([0-9]+)&#34;, file_string), dtype=int, count=len(file_list))
    asort = np.argsort(sim_num)
    sim_num = sim_num[asort]
    file_list = list(np.array(file_list)[asort])
    return file_list</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.id2xy"><code class="name flex">
<span>def <span class="ident">id2xy</span></span>(<span>idx, w=40, h=40)</span>
</code></dt>
<dd>
<div class="desc"><p>idx: index, w: width, h:height</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id2xy(idx, w=40, h=40):
    &#34;&#34;&#34;idx: index, w: width, h:height&#34;&#34;&#34;
    return r_id2xy(idx - 1, w, h)</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.load_msg"><code class="name flex">
<span>def <span class="ident">load_msg</span></span>(<span>afile:Â pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_msg(afile: Path):
    try:
        sim_id = search(&#34;\\d+&#34;, afile.stem).group(0)
    except:
        sim_id = &#34;-1&#34;
    data = loadtxt(
        afile, delimiter=&#34;,&#34;, dtype=[(&#34;i&#34;, np.int32), (&#34;j&#34;, np.int32), (&#34;t&#34;, np.int32)], usecols=(0, 1, 2), ndmin=1
    )
    return data, sim_id</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>argv=None)</span>
</code></dt>
<dd>
<div class="desc"><p>steps to run dpv</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(argv=None):
    &#34;&#34;&#34;steps to run dpv&#34;&#34;&#34;
    if argv is None:
        argv = sys.argv[1:]
    args = argument_parser(argv)
    logger = setup_logger(__name__, args.verbosity, args.logfile)
    logger.info(f&#34;{args=}&#34;)
    logger.debug(&#34;debugging...&#34;)

    file_list = []
    for path_str in args.messages:
        path = Path(path_str)
        if path.is_file() and path.stat().st_size &gt; 0:
            file_list += [path]
        elif path.is_dir():
            file_list += glob_int_sorted(path)
        else:
            logger.warning(f&#34;{path} is not a file or directory&#34;)
    # remove duplicates
    file_list = list(dict.fromkeys(file_list))
    logger.info(f&#34;{file_list=}&#34;)

    if args.protection_value:
        pv_data, pv_info = read_raster(str(args.protection_value), args.protection_value_band)
        W, H, GT, PJ = pv_info[&#34;RasterXSize&#34;], pv_info[&#34;RasterYSize&#34;], pv_info[&#34;Transform&#34;], pv_info[&#34;Projection&#34;]
        # make 1D
        pv = pv_data.ravel()
        logger.info(f&#34;{pv_data.dtype=}, {pv_data.shape=}, {pv_info=}&#34;)
        dpv = np.zeros(pv.shape, dtype=pv.dtype)
    elif args.W and args.H:
        W, H = args.W, args.H
        GT = (0, 1, 0, 0, 0, 1)
        PJ = &#34;EPSG:4326&#34;
        pv = np.ones(W * H, dtype=np.int32)
        dpv = np.zeros(W * H, dtype=np.int32)

    from multiprocessing import Pool, cpu_count

    with Pool(processes=cpu_count() - 1) as pool:
        results = [pool.apply_async(one_sim_work, args=(afile, pv, i)) for i, afile in enumerate(file_list)]
        for result in results:
            sdpv, si2n, sid = result.get()
            dpv[si2n] += sdpv
    # scale
    dpv = dpv / len(file_list)
    print(f&#34;{dpv=}&#34;)
    # write
    dst_ds = gdal.GetDriverByName(&#34;GTiff&#34;).Create(args.dpv_filename, W, H, 1, gdal.GDT_Float32)
    # get driver by name to create a geo tiff raster
    dst_ds.SetGeoTransform(GT)
    dst_ds.SetProjection(PJ)
    band = dst_ds.GetRasterBand(1)
    band.SetUnitType(&#34;protection_value&#34;)
    if 0 != band.SetNoDataValue(0):
        feedback.pushWarning(f&#34;Set No Data failed for {self.OUT_R}&#34;)
    if 0 != band.WriteArray(np.float32(dpv.reshape(H, W))):
        feedback.pushWarning(f&#34;WriteArray failed for {self.OUT_R}&#34;)
    band.FlushCache()
    dst_ds.FlushCache()
    dst_ds = None
    return 0</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.no"><code class="name flex">
<span>def <span class="ident">no</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def no():
    # if len(sys.argv)&gt;1:
    #     input_dir = sys.argv[1]
    #     output_dir = sys.argv[2]
    # else:
    print(&#34;run in C2FSB folder&#34;)
    # input_dir = Path.cwd() / &#39;data&#39;
    input_dir = Path(&#34;/home/fdo/source/C2F-W3/data/Vilopriu_2013/firesim_231008_110004&#34;)
    # output_dir = Path.cwd() / &#39;results&#39;
    output_dir = Path(&#34;/home/fdo/source/C2F-W3/data/Vilopriu_2013/firesim_231008_110004/results&#34;)
    print(input_dir, output_dir)
    assert input_dir.is_dir() and output_dir.is_dir()

    # abro el directorio de los messages como una lista con los nombres de los archivos
    file_list = read_files(output_dir)

    # agarrar la capa que ocuparemos como valor a proteger
    ## pv: valores en riesgo
    ## W: Width
    ## H: Height
    pv, W, H = get_flat_pv(input_dir / &#34;fuels.asc&#34;)

    #
    # single simulation
    #
    afile = file_list[0]
    msgG, root = digraph_from_messages(afile)
    pos = {node: [*id2xy(node)] for node in msgG}
    treeG = shortest_propagation_tree(msgG, root)

    # count the number of nodes downstream
    countG = count_downstream_graph(treeG, root)

    # asignar el nÃºmero de nodos aguas abajo a cada nodo respectivamente
    countGv = {n: countG.nodes[n][&#34;dv&#34;] for n in countG}
    plot(countG, pos=pos, labels=countGv)
    # {&#39;dv&#39;: 137} == 137 root connects all tree
    assert countG.nodes[root][&#34;dv&#34;] == len(countG), &#34;count_downstream at root is not the same as number of nodes!&#34;
    #
    onev = np.ones(pv.shape)
    #
    # sum dpv=1
    sumG = sum_dpv_graph(treeG, root, onev)
    sumGv = {n: sumG.nodes[n][&#34;dv&#34;] for n in sumG}
    plot(sumG, pos=pos, labels=sumGv)
    assert np.all([sumGv[n] == countGv[n] for n in treeG.nodes]), &#34;sum_dpv(pv=1) != countG values!&#34;
    #
    # add dpv=1
    addG = treeG.copy()
    for n in addG.nodes:
        addG.nodes[n][&#34;dv&#34;] = 0
    add_dpv_graph(addG, root, onev)
    addGv = {n: addG.nodes[n][&#34;dv&#34;] for n in addG}
    plot(addG, pos=pos, labels=addGv)
    assert np.all([addGv[n] == countGv[n] for n in treeG.nodes]), &#34;add_dpv(pv=1) != countG values!&#34;
    #
    # cum dpv=1
    dpv = np.zeros(pv.shape, dtype=pv.dtype)
    i2n = [n - 1 for n in treeG]
    mdpv = dpv_maskG(treeG, root, onev, i2n)
    dpv[i2n] = mdpv
    plot_pv(dpv, w=W, h=H)
    assert np.all([mdpv[i2n.index(n - 1)] == countGv[n] for n in treeG.nodes]), &#34;dpv_maskG(pv=1) != countG values!&#34;
    #
    # single full test
    mdpv, dpv = single_simulation_downstream_protection_value(msgfile=afile, pvfile=input_dir / &#34;bp.asc&#34;)
    plot_pv(dpv, w=W, h=H)
    plot(treeG, pos=pos, labels={n: np.format_float_scientific(dpv[n], precision=2) for n in treeG})
    assert np.all(np.isclose(mdpv, dpv[i2n])), &#34;dpv_maskG != dpvalues!&#34;
    #
    # finally
    dpv = downstream_protection_value(output_dir, pvfile=input_dir / &#34;bp.asc&#34;)
    plot_pv(dpv, w=W, h=H)</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.one_sim_work"><code class="name flex">
<span>def <span class="ident">one_sim_work</span></span>(<span>afile, pv, sid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def one_sim_work(afile, pv, sid):
    # digraph_from_messages(msgfile) -&gt; msgG, root
    data = np.loadtxt(
        afile,
        delimiter=&#34;,&#34;,
        dtype=[(&#34;i&#34;, np.int32), (&#34;j&#34;, np.int32), (&#34;t&#34;, np.int32)],
        usecols=(0, 1, 2),
        ndmin=1,
    )
    # 1 based to 0 based
    data[&#34;i&#34;] -= 1
    data[&#34;j&#34;] -= 1
    msgG = nx.DiGraph()
    msgG.add_weighted_edges_from(data)
    root = data[0][0]
    # shortest_propagation_tree(G, root) -&gt; treeG
    shortest_paths = nx.single_source_dijkstra_path(msgG, root, weight=&#34;time&#34;)
    del shortest_paths[root]
    treeG = nx.DiGraph()
    for node, shopat in shortest_paths.items():
        for i, node in enumerate(shopat[:-1]):
            treeG.add_edge(node, shopat[i + 1])
    # dpv_maskG(G, root, pv, i2n) -&gt; mdpv
    i2n = [n for n in treeG]
    mdpv = pv[i2n]
    recursion2(treeG, root, mdpv, i2n)
    # dpv[i2n] += mdpv
    print(&#34;fin&#34;, sid)
    return mdpv, i2n, sid</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>G, pos=None, labels=None)</span>
</code></dt>
<dd>
<div class="desc"><p>matplotlib
TODO scientific format numeric labels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(G, pos=None, labels=None):
    &#34;&#34;&#34;matplotlib
    TODO scientific format numeric labels
    &#34;&#34;&#34;
    if not pos:
        pos = {node: [*id2xy(node)] for node in G.nodes}
    if not labels:
        labes = {node: node for node in G.nodes}
    plt.figure()
    nx.draw(G, pos=pos, with_labels=False)
    nx.draw_networkx_labels(G, pos=pos, labels=labels)
    return plt.show()</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.plot_pv"><code class="name flex">
<span>def <span class="ident">plot_pv</span></span>(<span>pv, w=40, h=40)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_pv(pv, w=40, h=40):
    mat = pv.reshape(h, w)
    plt.matshow(mat)
    plt.show()</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.recursion2"><code class="name flex">
<span>def <span class="ident">recursion2</span></span>(<span>G:Â networkx.classes.digraph.DiGraph, i:Â numpy.int32, mdpv:Â numpy.ndarray, i2n:Â list[int]) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recursion2(G: DiGraph, i: np.int32, mdpv: ndarray, i2n: list[int]) -&gt; ndarray:
    for j in G.successors(i):
        mdpv[i2n.index(i)] += recursion2(G, j, mdpv, i2n)
    return mdpv[i2n.index(i)]</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.recursiveUp"><code class="name flex">
<span>def <span class="ident">recursiveUp</span></span>(<span>G)</span>
</code></dt>
<dd>
<div class="desc"><p>count up WTF!!!
leafs = [x for x in T.nodes if T.out_degree(x)==0]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recursiveUp(G):
    &#34;&#34;&#34;count up WTF!!!
    leafs = [x for x in T.nodes if T.out_degree(x)==0]
    &#34;&#34;&#34;
    for i in G.nodes:
        G.nodes[i][&#34;dv&#34;] = 1

        # G.nodes[i][&#39;dv&#39;]=0
    # for leaf in (x for x in G.nodes if G.out_degree(x)==0):
    #    G.nodes[leaf][&#39;dv&#39;]=1
    def count_up(G, j):
        for i in G.predecessors(j):
            # G.nodes[i][&#39;dv&#39;]+=G.nodes[j][&#39;dv&#39;]
            G.nodes[i][&#34;dv&#34;] += 1
            print(i, j, G.nodes[i][&#34;dv&#34;])
            count_up(G, i)

    for leaf in (x for x in G.nodes if G.out_degree(x) == 0):
        count_up(G, leaf)</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.shortest_propagation_tree"><code class="name flex">
<span>def <span class="ident">shortest_propagation_tree</span></span>(<span>G, root)</span>
</code></dt>
<dd>
<div class="desc"><p>construct a tree with the all shortest path from root
TODO try accumulating already added edges for checking before asigning should be faster?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shortest_propagation_tree(G, root):
    &#34;&#34;&#34;construct a tree with the all shortest path from root
    TODO try accumulating already added edges for checking before asigning should be faster?
    &#34;&#34;&#34;
    # { node : [root,...,node], ... }
    shortest_paths = nx.single_source_dijkstra_path(G, root, weight=&#34;time&#34;)
    del shortest_paths[root]
    T = nx.DiGraph()
    for node, shopat in shortest_paths.items():
        for i, node in enumerate(shopat[:-1]):
            T.add_edge(node, shopat[i + 1])
    return T</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.single_simulation_downstream_protection_value"><code class="name flex">
<span>def <span class="ident">single_simulation_downstream_protection_value</span></span>(<span>msgfile='MessagesFile01.csv', pvfile='py.asc')</span>
</code></dt>
<dd>
<div class="desc"><p>load one diGraph count succesors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def single_simulation_downstream_protection_value(msgfile=&#34;MessagesFile01.csv&#34;, pvfile=&#34;py.asc&#34;):
    &#34;&#34;&#34;load one diGraph count succesors&#34;&#34;&#34;
    msgG, root = digraph_from_messages(msgfile)
    treeG = shortest_propagation_tree(msgG, root)
    pv, W, H = get_flat_pv(pvfile)
    #
    dpv = np.zeros(pv.shape, dtype=pv.dtype)
    i2n = [n - 1 for n in treeG]
    mdpv = dpv_maskG(treeG, root, pv, i2n)
    dpv[i2n] = mdpv
    return mdpv, dpv</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.sum_dpv_graph"><code class="name flex">
<span>def <span class="ident">sum_dpv_graph</span></span>(<span>T, root, pv)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a copy of T that:
1. sets pv into each node
2. recursively sums pv downstream
T must be a tree (not checked)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum_dpv_graph(T, root, pv):
    &#34;&#34;&#34;returns a copy of T that:
        1. sets pv into each node
        2. recursively sums pv downstream
    T must be a tree (not checked)
    &#34;&#34;&#34;
    G = T.copy()
    for i in G.nodes:
        G.nodes[i][&#34;dv&#34;] = pv[i - 1]

    def recursion(G, i):
        for j in G.successors(i):
            G.nodes[i][&#34;dv&#34;] += recursion(G, j)
        return G.nodes[i][&#34;dv&#34;]

    recursion(G, root)
    return G</code></pre>
</details>
</dd>
<dt id="fire2a-lib.src.fire2a.downstream_protection_value.worker"><code class="name flex">
<span>def <span class="ident">worker</span></span>(<span>data, pv, sid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def worker(data, pv, sid):

    # digraph_from_messages(msgfile) -&gt; msgG, root
    msgG = DiGraph()
    msgG.add_weighted_edges_from(data)
    root = data[0][0]
    # shortest_propagation_tree(G, root) -&gt; treeG
    shortest_paths = nx.single_source_dijkstra_path(msgG, root, weight=&#34;time&#34;)
    del shortest_paths[root]
    treeG = DiGraph()
    for node, shopat in shortest_paths.items():
        for i, node in enumerate(shopat[:-1]):
            treeG.add_edge(node, shopat[i + 1])
    # dpv_maskG(G, root, pv, i2n) -&gt; mdpv
    i2n = [n for n in treeG]
    mdpv = pv[i2n]
    recursion(treeG, root, mdpv, i2n)
    # dpv[i2n] += mdpv
    return mdpv, i2n, sid</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fire2a-lib.src.fire2a" href="index.html">fire2a-lib.src.fire2a</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.add_dpv_graph" href="#fire2a-lib.src.fire2a.downstream_protection_value.add_dpv_graph">add_dpv_graph</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.argument_parser" href="#fire2a-lib.src.fire2a.downstream_protection_value.argument_parser">argument_parser</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.canon3" href="#fire2a-lib.src.fire2a.downstream_protection_value.canon3">canon3</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.canon4" href="#fire2a-lib.src.fire2a.downstream_protection_value.canon4">canon4</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.count_downstream_graph" href="#fire2a-lib.src.fire2a.downstream_protection_value.count_downstream_graph">count_downstream_graph</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.custom4" href="#fire2a-lib.src.fire2a.downstream_protection_value.custom4">custom4</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.digraph_from_messages" href="#fire2a-lib.src.fire2a.downstream_protection_value.digraph_from_messages">digraph_from_messages</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.downstream_protection_value" href="#fire2a-lib.src.fire2a.downstream_protection_value.downstream_protection_value">downstream_protection_value</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.dpv_maskG" href="#fire2a-lib.src.fire2a.downstream_protection_value.dpv_maskG">dpv_maskG</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.get_data" href="#fire2a-lib.src.fire2a.downstream_protection_value.get_data">get_data</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.get_flat_pv" href="#fire2a-lib.src.fire2a.downstream_protection_value.get_flat_pv">get_flat_pv</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.glob_int_sorted" href="#fire2a-lib.src.fire2a.downstream_protection_value.glob_int_sorted">glob_int_sorted</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.id2xy" href="#fire2a-lib.src.fire2a.downstream_protection_value.id2xy">id2xy</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.load_msg" href="#fire2a-lib.src.fire2a.downstream_protection_value.load_msg">load_msg</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.main" href="#fire2a-lib.src.fire2a.downstream_protection_value.main">main</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.no" href="#fire2a-lib.src.fire2a.downstream_protection_value.no">no</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.one_sim_work" href="#fire2a-lib.src.fire2a.downstream_protection_value.one_sim_work">one_sim_work</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.plot" href="#fire2a-lib.src.fire2a.downstream_protection_value.plot">plot</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.plot_pv" href="#fire2a-lib.src.fire2a.downstream_protection_value.plot_pv">plot_pv</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.recursion2" href="#fire2a-lib.src.fire2a.downstream_protection_value.recursion2">recursion2</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.recursiveUp" href="#fire2a-lib.src.fire2a.downstream_protection_value.recursiveUp">recursiveUp</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.shortest_propagation_tree" href="#fire2a-lib.src.fire2a.downstream_protection_value.shortest_propagation_tree">shortest_propagation_tree</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.single_simulation_downstream_protection_value" href="#fire2a-lib.src.fire2a.downstream_protection_value.single_simulation_downstream_protection_value">single_simulation_downstream_protection_value</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.sum_dpv_graph" href="#fire2a-lib.src.fire2a.downstream_protection_value.sum_dpv_graph">sum_dpv_graph</a></code></li>
<li><code><a title="fire2a-lib.src.fire2a.downstream_protection_value.worker" href="#fire2a-lib.src.fire2a.downstream_protection_value.worker">worker</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>